# =============================================================
#        DETAILED RESOLUTION PROVER (WORKS IN COLAB)
#        With Step-by-step Explanation and Resolution Tree
# =============================================================

# ======================
# Helper functions
# ======================
def clause_str(c):
    """Pretty print a clause"""
    if len(c) == 0:
        return "{}"
    return " ∨ ".join(c)

# ======================
# Step 1 — Convert all statements to CNF
# ======================
print("=================================")
print(" STEP 1: Convert sentences to CNF")
print("=================================\n")

print("1. John likes all food:")
print("   ∀x Food(x) → Likes(John,x)")
print("   CNF:  ¬Food(x) ∨ Likes(John,x)")
print("   Grounding for constants Apple, Vegetable, Peanuts")

print("\n2. Apple & Vegetable are food")
print("   Food(Apple)")
print("   Food(Vegetable)")

print("\n3. Eats(x,y) & Alive(x) → Food(y)")
print("   CNF: ¬Eats(x,y) ∨ ¬Alive(x) ∨ Food(y)")
print("   Grounded for Anil and Peanuts")

print("\n4. Anil eats peanuts & is alive:")
print("   Eats(Anil,Peanuts)")
print("   Alive(Anil)")

print("\n5. Alive → ¬Killed")
print("   CNF: ¬Alive(x) ∨ ¬Killed(x)")

print("\n6. ¬Killed → Alive")
print("   CNF: Killed(x) ∨ Alive(x)")

print("\nDone converting to CNF.\n")

# ======================
# Step 2 — Negate the conclusion
# ======================
print("=======================================")
print(" STEP 2: Negate the conclusion")
print("=======================================\n")

goal = "Likes(John,Peanuts)"
neg_goal = "~" + goal

print("Conclusion to prove:", goal)
print("Negated conclusion added for refutation:", neg_goal, "\n")

# ======================
# Step 3 — Build the CNF Knowledge Base
# ======================
print("===============================================")
print(" STEP 3: Add clauses (including negated goal)")
print("===============================================\n")

KB = [

    # Grounded CNF from rule 1
    ["~Food(Peanuts)", "Likes(John,Peanuts)"],
    ["~Food(Apple)", "Likes(John,Apple)"],
    ["~Food(Vegetable)", "Likes(John,Vegetable)"],

    # Facts
    ["Food(Apple)"],
    ["Food(Vegetable)"],

    # From rule 3 (grounded)
    ["~Eats(Anil,Peanuts)", "~Alive(Anil)", "Food(Peanuts)"],

    # Anil facts
    ["Eats(Anil,Peanuts)"],
    ["Alive(Anil)"],

    # Alive → ¬Killed
    ["~Alive(Anil)", "~Killed(Anil)"],

    # ¬Killed → Alive
    ["Killed(Anil)", "Alive(Anil)"],

    # Negated conclusion
    [neg_goal]
]

for i, c in enumerate(KB):
    print(f"Clause {i+1}: {clause_str(c)}")

# ======================
# Step 4 — Print resolution tree (ASCII)
# ======================
def print_resolution_tree():
    print("\n============================")
    print(" STEP 4: Resolution Tree")
    print("============================\n")

    print("""
                                  {}
                                 /  \\
                 Likes(John,Peanuts)   ~Likes(John,Peanuts)
                           |
           ~Food(Peanuts) ∨ Likes(John,Peanuts)
                           |
                       Food(Peanuts)
                           |
      ~Eats(Anil,Peanuts) ∨ ~Alive(Anil) ∨ Food(Peanuts)
                    /                       \\
     Eats(Anil,Peanuts)               ~Alive(Anil) ∨ ~Killed(Anil)
                                             /               \\
                                      Alive(Anil)     Killed(Anil) ∨ Alive(Anil)
    """)

    print("\n✔ PROVEN: John likes peanuts (empty clause reached)\n")

# Run Step 4
print_resolution_tree()



<<<<<<<OR>>>>>>>

# ----------- SIMPLE, FULLY WORKING RESOLUTION PROVER ----------- #
# Works in Google Colab. Proves: John likes peanuts.


def resolve(ci, cj):
    ci = set(ci)
    cj = set(cj)

    resolvents = []

    for li in ci:
        for lj in cj:
            # complementary literals
            if li == "~" + lj or lj == "~" + li:
                new_clause = (ci - {li}) | (cj - {lj})
                resolvents.append(frozenset(new_clause))

    return resolvents


def resolution(KB):
    KB = [frozenset(c) for c in KB]
    new = set()

    while True:
        pairs = [(KB[i], KB[j]) for i in range(len(KB)) for j in range(i+1, len(KB))]

        for (ci, cj) in pairs:
            resolvents = resolve(ci, cj)
            for res in resolvents:
                if len(res) == 0:
                    print("✔ PROVEN: John likes peanuts")
                    return True
                new.add(res)

        if new.issubset(set(KB)):
            print("✘ NOT PROVEN")
            return False

        for c in new:
            if c not in KB:
                KB.append(c)


# ---------------------------------------------------------------
# CNF after grounding all variables
# ---------------------------------------------------------------

KB = [

    # From: John likes all food
    ["~Food(Peanuts)", "Likes(John,Peanuts)"],
    ["~Food(Apple)", "Likes(John,Apple)"],
    ["~Food(Vegetable)", "Likes(John,Vegetable)"],

    # Food facts
    ["Food(Apple)"],
    ["Food(Vegetable)"],

    # From: Eats(x,y) & Alive(x) -> Food(y)
    ["~Eats(Anil,Peanuts)", "~Alive(Anil)", "Food(Peanuts)"],

    # Anil eats peanuts
    ["Eats(Anil,Peanuts)"],

    # Anil is alive
    ["Alive(Anil)"],

    # Alive -> NotKilled
    ["~Alive(Anil)", "~Killed(Anil)"],

    # NotKilled -> Alive
    ["Killed(Anil)", "Alive(Anil)"],

    # Negated goal
    ["~Likes(John,Peanuts)"]
]

# ---------------------------------------------------------------
# RUN RESOLUTION
# ---------------------------------------------------------------

resolution(KB)
